// 핵심 #1. 공통성과 가변성의 분리 => 2일차 오전
// => 공통으로 사용되는 코드(변하지 않는것) 와 사용자가 변경할수 있게하는 코드를 분리

// => 변하는 것을 분리하는 2가지 기술
// 1. 변하는 것을 가상함수로    : template method => 도형편집기 예제 draw/draw_imp
// 2. 변하는 것을 다른 클래스로 : strategy(Edit/IValidator 예제), 
//								policy base design ( C++ IDioms, vector/allocator)
//							   







// 핵심 #2. 재귀적 포함 - 2일차 오후 ~ 3일차 오전. 
// => A를 B를 포함 하지만 A 자신도 포함할수 있다.
// => A 와 B는 공통의 기반 클래스가 필요 한다.

// composite : 재귀적 포함을 사용해서 "복합객체(PopupMenu)" 를 만들기 위해
//				Menu 예제(PopupMenu, MenuItem)

// decorator : "객체에 동적으로 기능을 추가" 
//			   기능을 중첩해서 추가하기 위해서 "재귀적 포함" 을 사용.
//				FileStream, ZipDecorator 예제












// 핵심 #3. 간접층의 원리
// => 간접층(중간층)을 도입해서 문제를 해결.
// => 그런데, 왜 중간층을 도입했는가 ?? 어떤 문제를 해결하기 위해서 중간층을
//    도입했는가에 따라 패턴의 이름을 다릅니다.

// 사용자 ================ stack ===================> list
//										// 인터페이스의 변경을 위한 중간층 도입
//										// list 를 stack 처럼 보이게 하려고!
//										// adapter 패턴
// 
// 사용자 ================ MP3   ===================> IMP3, IPod
//										// 구현부와 추상층(간접층)의 독립된 update
//										// 구현이 변경되어도 사용자 코드는 변경될 필요없게!
//										// bridge
// 
// 사용자 ================ TCPServer ===============> Socket, IPAddress
//										// 복잡한 절차를 단순화 하는 상위 레벨의 클래스
//										// "사용하기 쉽게" 가 가장 큰 목적!!!
//										// facade
// 
// Client ================ Calc     ===============> IPC Server
//										// 다양한 의도를 가진 범용적인 용도의 대행자
										// 대신 할수 있는 객체를 만드는 것
										// proxy





// 핵심 #4. 객체의 생성기술
